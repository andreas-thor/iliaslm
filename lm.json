{
	"title": "y6DBS Lernmodul (aus JSON erzeugt)",
	"chapter": [
		{
			"name": "01_INTRO",
			"title": "01 INTRO: Einführung",
			"page": [
				{
					"name": "overview",
					"title": "Übersicht",
					"outcome": [
						"Vorteile der Datenhaltung mittels Datenbanksystemen gegenüber Dateisystemen zu erklären",
						"die wesentlichen Eigenschaften relationaler Datenbanksysteme zu erläutern",
						"das Transaktionskonzept und die Transaktionseigenschaften (ACID) an einem Beispiel darzustellen",
						"praktische Einsatzszenarien den DBS-Einsatzformen OLTP und OLAP zuzuordnen"
					]
				},
				{
					"name": "Datenbanksystem",
					"title": "Datenbankystem"
				},
				{
					"name": "Relationenmodell_Beispiel",
					"title": "Relationenmodell (Beispiel)",
					"question": [
						{
							"type": "gap",
							"text": "Wir betrachten die Tabelle Student. Geben Sie für die folgenden Elemente an, ob es sich um Metadaten oder Instanzdaten handelt!\n\n* Tabellenname Student: |*Metadaten; Instanzdaten|\n* Attributwert 101 für Student Schmidt: |Metadaten; *Instanzdaten|\n* Attributname W-Ort: |*Metadaten; Instanzdaten|\n* Attributwerte des letzten Datensatzes: |Metadaten; *Instanzdaten|"
						},
						{
							"type": "gap",
							"text": "Geben Sie für jede der Anfragen an, wieviele Tabellen zur Beantwortung verwendet werden!\n\n* Liste der Namen aller Studenten: |*1;2;3;4|\n* Liste der Büros aller Professoren aus dem Wirtschafts-Department: |1;*2;3;4|\n* Namen der Studenten, die von einem Professor aus dem Wirtschafts-Department mit der Note 1.3 geprüft wurden? |1;2;3;*4|"
						}
					]
				},
				{
					"name": "Drei_Schema_Architektur",
					"title": "Drei-Schema-Architektur"
				},
				{
					"name": "Transaktion_Beispiel",
					"title": "Transaktion (Beispiel)"
				},
				{
					"name": "DBS_Nutzer",
					"title": "Datenbank-Nutzer",
					"question": [
						{
							"type": "gap",
							"text": "Ordnen Sie die folgenden Eigenschaften dem jeweiligen Nutzer zu!\n\n* Hat mit seinem Domänenwissen die Datenbank modelliert, d.h. Tabellen erstellt: |Endbenutzer von DB-Anwendungen; Anwendungsprogrammierer; DB-Analyst; *DB-Modellierer; DB-Administrator; DBMS-Implementierer|\n* Kennt den Aufbau der Datenbank (Tabellen, Attribute) und erstellt SQL-Anfragen: |Endbenutzer von DB-Anwendungen; *Anwendungsprogrammierer; DB-Analyst; DB-Modellierer; DB-Administrator; DBMS-Implementierer|\n* Benötigt keine Datenbankkenntnisse: |*Endbenutzer von DB-Anwendungen; Anwendungsprogrammierer; DB-Analyst; DB-Modellierer; DB-Administrator; DBMS-Implementierer|\n* Analysiert Anfragen und Datenmengen und optimiert ggf. die Datenbank: |Endbenutzer von DB-Anwendungen; Anwendungsprogrammierer; *DB-Analyst; DB-Modellierer; DB-Administrator; DBMS-Implementierer|\n* Hat das DBMS (z.B. DB2) implementiert: |Endbenutzer von DB-Anwendungen; Anwendungsprogrammierer; DB-Analyst; DB-Modellierer; DB-Administrator; *DBMS-Implementierer|\n* Kümmert sich um die Nutzer- und Rechte-Verwaltung: |Endbenutzer von DB-Anwendungen; Anwendungsprogrammierer; DB-Analyst; DB-Modellierer; *DB-Administrator; DBMS-Implementierer|"
						}
					]
				}
			]
		},
		{
			"name": "02_RM",
			"title": "02 RM: Das Relationale Modell",
			"page": [
				{
					"name": "overview",
					"title": "Übersicht",
					"outcome": [
						"Aufbau und Eigenschaften einer Relation zu erläutern",
						"Bedeutung und Funktionsweise von Primär- und Fremdschlüsseln darzustellen",
						"Relationen mittels Primär- und Fremdschlüsseln zu verknüpfen",
						"die verschiedenen Arten von Löschregeln und ihre Funktionsweise an konkreten Beispielen umzusetzen"
					]
				},
				{
					"name": "Relationen_in_Tabellendarstellung",
					"title": "Relation in Tabellendarstellung",
					"question": [
						{
							"type": "gap",
							"text": "Beantworten Sie die folgenden Fragen zur dargestellten Relation PROFESSOR!\n\n* Was ist die Kardinalität der Relation? |1;2;3;*4;5;6;7;8;9;20;25;26|\n* Was ist der Grad der Relation? |1;2;3;4;*5;6;7;8;9;20;25;26|\n* Was ist der Wertebereich (Domäne) des Attributs PNr? |*INTEGER (ganze Zahl); VARCHAR (Zeichenkette)|"
						},
						{
							"type": "gap",
							"text": "Beantworten Sie die folgenden Fragen zur dargestellten Relation STUDENT!\n\n* Was ist die Kardinalität der Relation? |1;2;3;4;*5;6;7;8;9;20;25;26|\n* Was ist der Grad der Relation? |1;2;*3;4;5;6;7;8;9;20;25;26|\n* Welches Attribut hat einen NULL-Wert? |MatNr; SName; *W-Ort; 104; Krause|\n* Was ist der Wertebereich (Domäne) des Attributs W-Ort? |INTEGER (ganze Zahl); *VARCHAR (Zeichenkette)|"
						}
					]
				},
				{
					"name": "Schluesselkandidat",
					"title": "Schlüsselkandidat",
					"question": [
						{
							"type": "mc",
							"text": "Markieren Sie alle Schlüsselkandidaten der Relation PROFESSOR!| Büro; DPT; PName;  PName + Büro; *PNr; PNr + PName; *Telefon"
						},
						{
							"type": "mc",
							"text": "Markieren Sie alle Schlüsselkandidaten der Relation STUDENT!| *MatNr; MatNr + SName; SName; SName + W-Ort; W-Ort"
						}
					]
				},
				{
					"name": "Primaerschluessel",
					"title": "Primärschlüssel",
					"question": [
						{
							"type": "mc",
							"text": "Markieren Sie die korrekten Aussagen bzgl. der dargestellten Relation PROFESSOR mit dem Primärschlüssel PNr.\n\nDie dargestellte Relation PROFESSOR ist... | nicht gültig, da es Tupel mit NULL-Werten gibt; nicht gültig, da es mehrere Tupel mit gleichem Primärschlüssel-Wert gibt. ; *gültig"
						},
						{
							"type": "mc",
							"text": "Markieren Sie die korrekten Aussagen bzgl. der dargestellten Relation STUDENT mit dem Primärschlüssel MatNr.\n\nDie dargestellte Relation STUDENT ist... | *nicht gültig, da es mehrere Tupel mit gleichem Primärschlüssel-Wert gibt; nicht gültig, da für Student Krause der W-Ort einen NULL-Wert hat; *nicht gültig, da ein Tupel einen NULL-Wert für den Primärschlüssel hat.; gültig."
						}
					]
				},
				{
					"name": "Fremdschluessel",
					"title": "Fremdschlüssel",
					"question": [
						{
							"type": "gap",
							"text": "Geben Sie für die nachfolgenden Attribute der Relation DEPARTMENT an, ob Sie Fremdschlüssel sind. Falls ja, geben Sie den zugehörigen Primärschlüssel an.\n\n* ID: | *kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |\n* DName: | *kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |\n* Leiter: | kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; *Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |"
						},
						{
							"type": "gap",
							"text": "Geben Sie für die nachfolgenden Attribute der Relation PROFESSOR an, ob Sie Fremdschlüssel sind. Falls ja, geben Sie den zugehörigen Primärschlüssel an.\n\n* PNr: | *kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |\n* PName: | *kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |\n* Dept: | kein Fremdschlüssel; *Fremdschlüssel auf DEPARTMENT.ID; Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |"
						},
						{
							"type": "gap",
							"text": "Geben Sie für die nachfolgenden Attribute der Relation STUDENT an, ob Sie Fremdschlüssel sind. Falls ja, geben Sie den zugehörigen Primärschlüssel an.\n\n* MatNr: | *kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |\n* SName: | *kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |\n* W-Ort: | *kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |"
						},
						{
							"type": "gap",
							"text": "Geben Sie für die nachfolgenden Attribute der Relation PRÜFUNG an, ob Sie Fremdschlüssel sind. Falls ja, geben Sie den zugehörigen Primärschlüssel an.\n\n* PNr: | kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; *Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |\n* MatNr: | kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; Fremdschlüssel auf PROFESSOR.PNr; *Fremdschlüssel auf STUDENT.MatNr |\n* Fach: | *kein Fremdschlüssel; Fremdschlüssel auf DEPARTMENT.ID; Fremdschlüssel auf PROFESSOR.PNr; Fremdschlüssel auf STUDENT.MatNr |"
						}
					]
				},
				{
					"name": "Relationenmodell_in_SQL",
					"title": "Relationenmodell in SQL"
				},
				{
					"name": "Wartung_Referentielle_Integritaet_Beispiel",
					"title": "Wartung Referentielle Integrität",
					"question": [
						{
							"type": "gap",
							"text": "Geben Sie die Auswirkung der Operation \"DELETE FROM Student WHERE MatNr=101\" für jede der drei Löschregeln an:\n\n* NO ACTION: | Nur der Student Schmidt wird gelöscht.; Nur beide Prüfungen vom Studenten Schmidt werden gelöscht.; Student Schmidt und seine beiden Prüfungen werden gelöscht.; Student Schmidt wird gelöscht und die MatNr bei seinen Prüfungen wird auf NULL gesetzt.; *Es wird nichts gelöscht. |\n* CASCADE: | Nur der Student Schmidt wird gelöscht.; Nur beide Prüfungen vom Studenten Schmidt werden gelöscht.; *Student Schmidt und seine beiden Prüfungen werden gelöscht.; Student Schmidt wird gelöscht und die MatNr bei seinen Prüfungen wird auf NULL gesetzt.; Es wird nichts gelöscht. |\n* SET NULL: | Nur der Student Schmidt wird gelöscht.; Nur beide Prüfungen vom Studenten Schmidt werden gelöscht.; Student Schmidt und seine beiden Prüfungen werden gelöscht.; Student Schmidt wird gelöscht und die MatNr bei seinen Prüfungen wird auf NULL gesetzt.; *Es wird nichts gelöscht. |"
						}
					]
				}
			]
		},
		{
			"name": "03_SQL-1",
			"title": "03 SQL-1: Datenbanksprache SQL (Teil 1)",
			"page": [
				{
					"name": "overview",
					"title": "Übersicht",
					"outcome": [
						"den grundsätzlichen Aufbau einfacher SQL-SELECT-Anweisungen zu erklären (Attributauswahl in SELECT, WHERE-Bedignung, JOIN)",
						"das Ergebnis von SQL-SELECT-Anweisungen für gegebene Relationen zu berechnen",
						"die unterschiedlichen JOIN-Arten zu erklären",
						"SQL-SELECT-Anweisungen zu formulieren"
					]
				},
				{
					"name": "Einfache_Selektionen_und_Projektionen",
					"title": "Selektion und Projektion",
					"question": [
						{
							"type": "gap",
							"text": "Was berechnen jeweils die folgenden SQL-Anfragen? \n\n <code>SELECT name FROM verlag</code> | *Name aller Verlage; Name aller Berliner Verlage; Name und Ort aller Berliner Verlage; Ort aller Verlage| \n\n <code>SELECT name FROM verlag WHERE ort = \"Berlin\"</code> | Name aller Verlage; *Name aller Berliner Verlage; Name und Ort aller Berliner Verlage; Ort aller Verlage| \n\n <code>SELECT titel FROM buch WHERE jahr > 1990</code> | Titel der Bücher, die vor 1990 erschienen sind; Titel der Bücher, die 1990 erschienen sind; *Titel der Bücher, die nach 1990 erschienen sind | \n\n"
						},
						{
							"type": "gap",
							"text": "Welche SQL-Anfrage berechnet jeweils die folgenden Ergebnisse?\n\n<code>Name\n-------------------\nLunetIX SoftAir\nAkademie Verl.\nSchmidt</code>\n | SELECT name FROM verlag; SELECT name FROM verlage WHERE \"Berlin\"; *SELECT name FROM verlage WHERE ort=\"Berlin\"; SELECT ort FROM verlag | \n\n<code>Titel\n------------------\nExcel\nGrundlagen\nPC Tools\nInfo für Ing.\nJava</code>\n | SELECT titel FROM buch; SELECT titel, jahr FROM buch WHERE jahr>1990; *SELECT titel FROM buch WHERE jahr>1990; SELECT jahr>1990 FROM buch"
						}
					]
				},
				{
					"name": "Sortierung",
					"title": "Sortierung",
					"question": [
						{
							"type": "gap",
							"text": "Ordnen Sie den folgenden SQL-Ergebnissen (d.h. Ergebnis-Tabellen) diejenigen SQL-Anfragen zu, die dieses Ergebnis produzieren! \nHinweis: Alle Anfragen beginnen mit \"SELECT titel, jahr FROM buch WHERE jahr > 1990\" und werden dann durch eine ORDER-BY-Klausel ergänzt. Wählen Sie daher die korrekte ORDER-BY-Klausel aus!\n<code>\nTitel ······· + Jahr\n --------------+-----\n Excel ······· + 1991\n Grundlagen ·· + 1991\n Info für Ing. + 1995\n Java ········ + 1996\n PC Tools ···· + 1993</code>\n|*ORDER BY titel ASC; ORDER BY titel DESC; ORDER BY jahr ASC, titel ASC; ORDER BY jahr ASC, titel DESC; ORDER BY jahr DESC, titel ASC; ORDER BY jahr DESC, titel DESC|  \n<code>\nTitel ······· + Jahr\n --------------+-----\n PC Tools ···· + 1993\n Java ········ + 1996\n Info für Ing. + 1995\n Grundlagen ·· + 1991\n Excel ······· + 1991</code>\n|ORDER BY titel ASC; *ORDER BY titel DESC; ORDER BY jahr ASC, titel ASC; ORDER BY jahr ASC, titel DESC; ORDER BY jahr DESC, titel ASC; ORDER BY jahr DESC, titel DESC|  \n<code>\nTitel ······· + Jahr\n --------------+-----\n Java ········ + 1996\n Info für Ing. + 1995\n PC Tools ···· + 1993\n Grundlagen ·· + 1991\n Excel ······· + 1991</code>\n|ORDER BY titel ASC; ORDER BY titel DESC; ORDER BY jahr ASC, titel ASC; ORDER BY jahr ASC, titel DESC; *ORDER BY jahr DESC, titel ASC; ORDER BY jahr DESC, titel DESC|  \n<code>\nTitel ······· + Jahr\n --------------+-----\n Java ········ + 1996\n Info für Ing. + 1995\n PC Tools ···· + 1993\n Excel ······· + 1991\n Grundlagen ·· + 1991</code>\n|ORDER BY titel ASC; ORDER BY titel DESC; ORDER BY jahr ASC, titel ASC; ORDER BY jahr ASC, titel DESC; *ORDER BY jahr DESC, titel ASC; ORDER BY jahr DESC, titel DESC  "
						}
					]
				},
				{
					"name": "Duplikateliminierung",
					"title": "Duplikateliminierung",
					"question": [
						{
							"type": "gap",
							"text": "  Geben Sie für die nachfolgenden SQL-Anfragen an, wieviele Datensätze (Tupel) das Ergebnis jeweils beinhaltet! \n\nSELECT ort FROM verlag : |0;1;2;3;4;5;*6;7;8;9| \n\nSELECT DISTINCT ort FROM verlag : |0;1;2;*3;4;5;6;7;8;9| \n\nSELECT name FROM verlag : |0;1;2;3;4;5;*6;7;8;9| \n\nSELECT DISTINCT name FROM verlag : |0;1;2;3;4;5;*6;7;8;9|"
						}
					]
				},
				{
					"name": "Ausgabebearbeitung_Fallunterscheidung",
					"title": "Fallunterscheidung"
				},
				{
					"name": "Join_Beispiel",
					"title": "Join (Beispiel)",
					"question": [
						{
							"type": "gap",
							"text": "Geben Sie das Ergebnis der Join-Anfrage \"Alle Buchtitel mit dem Ort ihres Verlags\" an, in dem Sie für jeden Buchtitel den zugehörigen Ort auswählen oder \"---\", falls das Buch nicht im Anfrageergebnis auftritt.\n \nExcel: |Berlin; *Düsseldorf; München; ---| \nGrundlagen: |*Berlin; Düsseldorf; München; ---| \nKaufverträge: |*Berlin; Düsseldorf; München; ---| \nPC Tools: |Berlin; Düsseldorf; München; *---| \nInfo für Ing.: |Berlin; *Düsseldorf; München; ---| \nSemantik: |Berlin; Düsseldorf; *München; ---| \nJava: |Berlin; *Düsseldorf; München; --- "
						}
					]
				},
				{
					"name": "Join-Anfragen-1",
					"title": "Join-Anfragen (1)",
					"question": [
						{
							"type": "gap",
							"text": "  Formulieren Sie die Anfrage \"Welche Buchtitel wurden von Berliner Verlagen herausgebracht\" in SQL. Vervollständigen Sie dazu die  nachfolgende SQL-Anfrage.\n\n  \nSELECT |buch.id; *buch.titel; verlag.name; verlag.ort| \nFROM buch, |buch; *verlag| \nWHERE |buch.buchid; buch.titel; *buch.verlagsid|  |>;*=;<| |verlag.name; *verlag.verlagsid; verlag.ort| \n |*AND; OR| |verlag.name; verlag.verlagsid; *verlag.ort| = 'Berlin'   "
						}
					]
				},
				{
					"name": "Join-Anfragen-2",
					"title": "Join-Anfragen (2)"
				},
				{
					"name": "Schreibweisen_Joins",
					"title": "Schreibweisen Join"
				},
				{
					"name": "Join-Anfragen-3",
					"title": "Join-Anfragen (3)"
				},
				{
					"name": "OuterJoin",
					"title": "Outer Join"
				}
			]
		},
		{
			"name": "03_SQL-2",
			"title": "03 SQL-2: Datenbanksprache SQL (Teil 2)",
			"page": [
				{
					"name": "overview",
					"title": "Übersicht",
					"outcome": [
						"die Funktionsweise komplexer SQL-Anweisungen zu erklären (inkl. Unterabfragen, Gruppierung, Aggregation, komplexer Prädikate)",
						"das Ergebnis von SQL-SELECT-Anweisungen  für gegebene Relationen zu berechnen",
						"SQL-Anweisungen (SELECT, INSERT, DELETE, UPDATE) zu formulieren"
					]
				},
				{
					"name": "SubQuery",
					"title": "SubQuery (Unterabfrage)"
				},
				{
					"name": "Einfach_vs_korrelierte_SubQuery",
					"title": "Einfache vs. korrelierte SubQuery"
				},
				{
					"name": "AggregatFunktion",
					"title": "Aggregatfunktion"
				},
				{
					"name": "AggregatFunktion_2",
					"title": "Aggregatfunktion (2)"
				},
				{
					"name": "AggregatFunktion_3",
					"title": "Aggregatfunktion (3)"
				},
				{
					"name": "Gruppierung",
					"title": "Gruppierung"
				},
				{
					"name": "Mehrere_Gruppierungsattribute",
					"title": "Mehrere Gruppierungsattribute"
				},
				{
					"name": "Having",
					"title": "HAVING-Prädikat"
				},
				{
					"name": "Like_Praedikat",
					"title": "LIKE-Prädikat"
				},
				{
					"name": "Between_Praedikat",
					"title": "BETWEEN-Prädikat"
				},
				{
					"name": "IN_Praedikat",
					"title": "IN-Prädikat"
				},
				{
					"name": "NULL_Problemfaelle",
					"title": "NULL-Werte: Problemfälle"
				},
				{
					"name": "NULL_Problemfaelle_2",
					"title": "NULL-Werte: Problemfälle (2)"
				},
				{
					"name": "Quantifizierte_Praedikate",
					"title": "Quantifizierte Prädikate"
				},
				{
					"name": "Existenztests",
					"title": "Existenztests"
				},
				{
					"name": "Existenztests_2",
					"title": "Existenztests (2)"
				},
				{
					"name": "Mengenoperatoren",
					"title": "Mengenoperatoren"
				},
				{
					"name": "INSERT",
					"title": "INSERT-Anweisung"
				},
				{
					"name": "UPDATE",
					"title": "UPDATE-Anweisung"
				},
				{
					"name": "DELETE",
					"title": "DELETE-Anweisung"
				},
				{
					"name": "MERGE",
					"title": "MERGE-Anweisung"
				}
			]
		},
		{
			"name": "04_ER",
			"title": "04 ER: Entity-Relationship-Modell",
			"page": [
				{
					"name": "overview",
					"title": "Übersicht",
					"outcome": [
						"Grundkonzepte der ER-Modellierung sowie der Abstraktionskonzepte zu erläutern",
						"selbstständig ER-Modelle für gegebene Anwendungsszenarien zu erstellen",
						"wichtige Kennzeichen in ER-Modellen (Schlüssel, Beziehungstypen, Kardinalitätsrestriktionen, schwache Entity-Mengen) festzulegen und zu begründen",
						"gegebene ER-Modelle zu interpretieren"
					]
				},
				{
					"name": "Attribute",
					"title": "Attribute"
				},
				{
					"name": "Anwendungsbeispiel1",
					"title": "Anwendungsbeispiel 1"
				},
				{
					"name": "Relationsships",
					"title": "Relationsships"
				},
				{
					"name": "Relationships_Rekursive_Beziehung",
					"title": "Relationships: Rekursive Beziehung"
				},
				{
					"name": "Beziehung_11",
					"title": "Beziehung 1:1"
				},
				{
					"name": "Beziehung_N1",
					"title": "Beziehung 1:N"
				},
				{
					"name": "Beziehung_NM",
					"title": "Beziehung N:M"
				},
				{
					"name": "Beziehung_Ueberblick",
					"title": "Beziehung: Überblick"
				},
				{
					"name": "Anwendungsbeispiel2",
					"title": "Anwendungsbeispiel 2"
				},
				{
					"name": "MinMaxNotation",
					"title": "Min-Max-Notation"
				},
				{
					"name": "Anwendungsbeispiel2_MinMaxNotation",
					"title": "Anwendungsbeispiel 2 mit Min-Max-Notation"
				},
				{
					"name": "Anwendungsbeispiel3",
					"title": "Anwendungsbeispiel 3"
				},
				{
					"name": "Arten_der_Spezialisierung",
					"title": "Arten der Spezialisierung"
				}
			]
		},
		{
			"name": "05_ER2RM",
			"title": "05 ER2RM: Umwandlung ER-Modelle in relationale Modelle",
			"page": [
				{
					"name": "overview",
					"title": "Übersicht",
					"outcome": [
						"Entity-Mengen und Relationship-Mengen inkl. Attribute der ER-Modellierung in Tabellen/Relationen zu überführen",
						"wichtige Kennzeichen in ER-Modellen (u.a. Schlüssel, Beziehungstypen, Kardinalitätsrestriktionen) durch entsprechende Eigenschaften der Relationen zu modellieren",
						"ER-Generalisierungen/Spezialisierungen in das Relationenmodell zu überführen und je nach Anwendungsfall ein geeignetes Verfahren anzuwenden und zu begründen"
					]
				},
				{
					"name": "EntityMenge",
					"title": "Entity-Menge"
				},
				{
					"name": "RelationshipMenge_NM",
					"title": "Relationship-Menge N:M"
				},
				{
					"name": "RelationshipMenge_N1",
					"title": "Relationship-Menge 1:N"
				},
				{
					"name": "MehrwertigeAttribute",
					"title": "Mehrwertiges Attribut"
				},
				{
					"name": "SchwacheEntityMenge",
					"title": "Schwache Entity-Menge"
				},
				{
					"name": "VertikalePartitionierung",
					"title": "Vertikale Partitionierung"
				},
				{
					"name": "HorizontalePartitionierung",
					"title": "Horizontale Partitionierung"
				},
				{
					"name": "VolleRedundanz",
					"title": "VolleRedundanz"
				},
				{
					"name": "WideTable",
					"title": "WideTable"
				},
				{
					"name": "Generalisierung_Beispiel",
					"title": "Generalisierung: Beispiel"
				},
				{
					"name": "Generalisierung_Vergleich",
					"title": "Generalisierung: Vergleich"
				}
			]
		},
		{
			"name": "06_NORM",
			"title": "06 NORM: Normalisierung von Relationen",
			"page": [
				{
					"name": "overview",
					"title": "Übersicht",
					"outcome": [
						"die Begriffe funktionale Abhängingkeiten und Normalformen (1NF, 2NF, 3NF, BCNF) zu erläutern",
						"negative Auswirkungen (Anomalien) schlechter Schemata am konkreten Beispiel zu identifizieren und zu begründen",
						"Schlüssel und Normalform eines gegebenen Relationenschema auf Basis funktionaler Abhängigkeiten zu bestimmen",
						"Relationen in höhere Normalformen zu überführen"
					]
				},
				{
					"name": "Schlechtes_Schema",
					"title": "Schlechtes Schema "
				},
				{
					"name": "Funktionale_Abhaengigkeit",
					"title": "Funktionale Abhängigkeit"
				},
				{
					"name": "Schluessel",
					"title": "Schlüssel"
				},
				{
					"name": "FA_und_Schluessel",
					"title": "FA und Schlüssel"
				},
				{
					"name": "Zweite_Normalform",
					"title": "Zweite Normalform (2NF)"
				},
				{
					"name": "Ueberfuehrung_in_2NF",
					"title": "Überführung in 2NF"
				},
				{
					"name": "Dritte_Normalform",
					"title": "Dritte Normalform (3NF)"
				},
				{
					"name": "Ueberfuehrung_in_3NF",
					"title": "Überführung in 3NF"
				},
				{
					"name": "Nachteile_3NF",
					"title": "Nachteile 3NF"
				},
				{
					"name": "Probleme_BCNF",
					"title": "Probleme BCNF"
				}
			]
		},
		{
			"name": "08_DK",
			"title": "08 DK: Datenkontrolle",
			"page": [
				{
					"name": "overview",
					"title": "Übersicht",
					"outcome": [
						"den Begriff Datenbank-Integrität die Datenbank-Methoden zur Zugriffskontrolle zu erläutern",
						"semantische Integritätsbedingungen an ein Schema zu definieren und bzgl. ihrer Eigenschaften zu klassifizieren",
						"gegebene semantische Integritätsbedingungen in einem Datenbankschema durch SQL-Anweisungen (TABLE-Definition, TRIGGER) umzusetzen",
						"Sichten auf gegebene Relationen zu definieren und zu interpretieren (u.a. einzuschätzen, ob die Sicht aktualisierbar ist)"
					]
				},
				{
					"name": "Transaktion_Beispiel",
					"title": "Transaktion (Beispiel)"
				},
				{
					"name": "IntBedingung_Beispiele",
					"title": "Integritätsbedingungen (Beispiel)"
				},
				{
					"name": "Kontrolle",
					"title": "Kontrolle semantischer Int.Bed.",
					"question": [
						{
							"type": "gap",
							"text": "Die Überwachnung von Integrtiätsbedingungen kann sowohl durch Anwendungsprogramme (AP) oder das Datenbanksystem (DBS) realisiert werden. Geben Sie für die nachfolgenden Kriterien an, welche Variante vorteilhafter ist.\n\n* Sicherheit und Konsistenzwahrung: |Anwendungsprogramm; *Datenbanksystem|\n* Aufwand zur Erstellung eines Anwendungsprogramms: |Anwendungsprogramm; *Datenbanksystem|\n* Unterstützung von DB-Änderungen: |Anwendungsprogramm; *Datenbanksystem|\n* Änderbarkeit von Integritätsbedingungen: |Anwendungsprogramm; *Datenbanksystem| \n* Mächtigkeit bzgl. Implementierung von Integritätsbedingung: |*Anwendungsprogramm; Datenbanksystem|"
						}
					]
				},
				{
					"name": "Modell_vs_Anwendung",
					"title": "Modellinhärente vs. anwendungsspezifische Int.Bed.",
					"question": [
						{
							"type": "gap",
							"text": "Geben Sie für die nachfolgenden Integritätsbedingungen jeweils an, ob es sich um eine modellinhärente oder eine anwendungsspezifische Integritätsbedingung handelt.\n\n* Alter >= 18: |modellinhärent; *anwendungsspezifisch|\n* Gehaltssumme < Budget: |modellinhärent; *anwendungsspezifisch|\n* PNR ist eindeutig: |*modellinhärent; anwendungsspezifisch|\n* Alter ist eine Zahl (Integer): |*modellinhärent; anwendungsspezifisch|\n* Gehalt darf (bei UPDATE) nicht kleiner werden: |modellinhärent; *anwendungsspezifisch|\n* Person.ANR hat Wert, der in Abteilung.ANR auftritt: |*modellinhärent; anwendungsspezifisch|"
						}
					]
				},
				{
					"name": "Reichweite",
					"title": "Reichweite von Int.Bed.",
					"question": [
						{
							"type": "gap",
							"text": "Geben Sie für die nachfolgenden Integritätsbedingungen die Reichweite an, d.h. Attribut, Tupel, Tabelle oder mehrere Tabellen.\n\n* Alter >= 18: |*Attribut; Tupel; Tabelle; Mehrere Tabellen|\n* Gehaltssumme < Budget: |Attribut; *Tupel; Tabelle; Mehrere Tabellen|\n* PNR ist eindeutig: |Attribut; Tupel; *Tabelle; Mehrere Tabellen|\n* Gehaltssumme ist Summe der Gehalts-Werte der zugehörigen Personen: |Attribut; Tupel; Tabelle; *Mehrere Tabellen|\n* Gehalt darf (bei UPDATE) nicht kleiner werden: |Attribut; *Tupel; Tabelle; Mehrere Tabellen|\n* Person.ANR hat Wert, der in Abteilung.ANR auftritt: |Attribut; Tupel; Tabelle; *Mehrere Tabellen|\n* Abteilung sind maximal 10 Personen zugeordnet: |Attribut; Tupel; *Tabelle; Mehrere Tabellen|"
						}
					]
				},
				{
					"name": "Dynamisch_vs_statisch",
					"title": "Dynamische vs. statische Int.Bed.",
					"question": [
						{
							"type": "gap",
							"text": "Geben Sie für die folgenden Integritätsbedingungen jeweils an, ob es sich um eine statische oder dynamische Integritätsbedingung handelt. In letzterem Fall geben Sie zuätzlich an, ob eine Übergangsbedingung oder eine temporale Bedingung vorliegt.\n\n* Alter >= 18: |*Statische Integritätsbedingung; Dynamische Integritätsbedingung (Übergangsbedingung); Dynamische Integritätsbedingung (temporale Bedingung)|\n* Gehaltssumme < Budget: |*Statische Integritätsbedingung; Dynamische Integritätsbedingung (Übergangsbedingung); Dynamische Integritätsbedingung (temporale Bedingung)|\n* Gehalt darf (bei UPDATE) nicht kleiner werden: |Statische Integritätsbedingung; *Dynamische Integritätsbedingung (Übergangsbedingung); Dynamische Integritätsbedingung (temporale Bedingung)|\n* Gehalt darf innerhalb von 3 Jahren nicht um mehr als 25% wachsen: |Statische Integritätsbedingung; Dynamische Integritätsbedingung (Übergangsbedingung); *Dynamische Integritätsbedingung (temporale Bedingung)|\n* Familienstand von \"ledig\" nach \"geschieden\" ist unzulässig:: |Statische Integritätsbedingung; *Dynamische Integritätsbedingung (Übergangsbedingung); Dynamische Integritätsbedingung (temporale Bedingung)|"
						}
					]
				},
				{
					"name": "Trigger",
					"title": "Trigger",
					"question": [
						{
							"type": "gap",
							"text": "TODO |*1;2|"
						}
					]
				},
				{
					"name": "Sicht_Beispiel",
					"title": "Sicht/View: Beispiel"
				},
				{
					"name": "Sicht_Semantik",
					"title": "Sicht/View: Semantik"
				},
				{
					"name": "Sicht_Aenderung",
					"title": "Sicht/View: Änderung"
				},
				{
					"name": "INSTEAD_OF_Trigger",
					"title": "INSTEAD-OF-Trigger"
				}
			]
		}
	]
}
